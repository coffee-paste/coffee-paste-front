'use strict'

import nodeFetch from 'node-fetch';
import fs from 'fs';
import path from 'path';
import jszip from 'jszip';


//#region Commons
// Build API based on develop branch, unless it's build for main branch, then use main branch API.
const ENV_BRANCH = process.env.GITHUB_REF !== 'main' ? 'develop' : 'main';
const SELF_NAME = 'generate-api.js';
const NODE_BUFFER = 'nodebuffer';

const SWAGGER_GEN_REQUEST_BODY = {
	"lang": "typescript-fetch",
	"specURL": `https://raw.githubusercontent.com/coffee-paste/coffee-paste-backend/${ENV_BRANCH}/src/swagger.json`,
	"type": "CLIENT",
	"codegenVersion": "V3",
	"options": {
		supportsES6: true,
	}
};
//#endregion Commons


//#region Swagger File Names
const CUSTOM_D_TS = 'custom.d.ts';
const CONFIGURATION_TS = 'configuration.ts';
const API_TS = 'api.ts';
const INDEX_TS = 'index.ts';
//#endregion Swagger File Names


//#region Output Paths
const OUTPUT_BASE_PATH = 'src/infrastructure/generated'
const SWAGGER_API_OUTPUT_PATH = `${OUTPUT_BASE_PATH}/api`;
const CHANNEL_SPEC_PATH = `${SWAGGER_API_OUTPUT_PATH}/channel-spec.ts`;
const PROXY_EMISSION_OUTPUT_DIR = `${OUTPUT_BASE_PATH}/proxies`
const PROXY_EMISSION_OUTPUT_FILE = `${PROXY_EMISSION_OUTPUT_DIR}/api-proxies.ts`
//#endregion Output Paths


//#region Re-writes
const PORTABLE_PORTABLE_FETCH_REGEX = /import.+portable\-fetch\.*?\"\.*?\;/;
const PORTABLE_ISOMORPHIC_FETCH_REGEX = /import.+isomorphic\-fetch\.*?\"\.*?\;/;
const PORTABLE_FETCH_REWRITE_CONTENT = 'const portableFetch = fetch;'
const PORTABLE_FETCH_ISOMORPHIC_REWRITE_CONTENT = 'const isomorphicFetch = fetch;'

const BASE_PATH_REGEX = /const\s+BASE_PATH\s+=\s+.+?\;/;
const BASE_PATH_REWRITE_CONTENT = `// Auto-generated by '${SELF_NAME}'\n\
import { envFacade } from '../../env-facade';\n\
const BASE_PATH = envFacade.apiUrl;`;

const CLASS_DEFS_REGEX = /export[\t ]+class\s+(?<className>[\w\d]+)\s+extends\s+BaseAPI/g;

const INJECT_PARAMS_FIND_REGEX = /localVarUrlObj.search = null;/g
const INJECT_PARAMS_FIND_CONTENT = "\
delete localVarUrlObj.search;\n\
			localVarRequestOptions.credentials = 'include';\n\
";
//#endregion Re-writes


//#region Proxies File

const AUTO_GEN_COMMENT = `\n// This file was AutoGenerated at ${new Date()} by '${SELF_NAME}'\n\n`

const PROXY_CORE_IMPORT_STATEMENT = "import { createApiProxy } from '@/infrastructure/api-proxy-core';\n";

const CRED_MGR_IMPORT_STATEMENT = "import { credentialsManager } from '@/infrastructure/session-management/credential-manager';\n";

const FACADE_CLASS_START_STATEMENT = '\n\nexport class ApiFacade {\n';
const FACADE_CLASS_END_STATEMENT = '}\n';

const PROXY_GETTER_STATEMENT_FORMAT = "\
	public static get {0}(): {0} {\n\
		return createApiProxy(new {0}({ apiKey: credentialsManager.getToken() }));\n\
	}\n\n"

//#endregion Proxies File


/**
 * Recursively ensures the given directory path exists, creating it as necessary
 *
 * @param {string} dirPath The path to ensure
 * @return {void} 
 */
function mkdirRecursive(dirPath) {
	if (fs.existsSync(dirPath)) {
		return;
	}
	const dirname = path.dirname(dirPath)
	mkdirRecursive(dirname);
	fs.mkdirSync(dirPath);
}

/**
 * Gets a file from the given `jsZip` archive and writes it to the `SWAGGER_API_OUTPUT_PATH`
 *
 * @param {JSZip} jsZip The archive containing the file
 * @param {string} fileName The file's name
 */
async function depositFile(jsZip, fileName) {
	const fileBuffer = await jsZip.file(fileName).async(NODE_BUFFER);
	fs.writeFileSync(path.join(SWAGGER_API_OUTPUT_PATH, fileName), fileBuffer);
}

/**
 * Creates an import statement for including the given 'importNames' from the generated api.ts file
 *
 * @param {string[]} importNames An array of entities to import  from 'api.ts'
 * @return {string[]} 
 */
function createImportStatement(importNames) {
	return `import { ${importNames.join(', ')} } from '../api/api'`;
}

/**
 * Creates the `api.ts` file
 * @description This method reads the `api.ts` from the Swagger generated archive,
 * amends it to fit our codebase and deposits it into `SWAGGER_API_OUTPUT_PATH`
 *
 * @param {JSZip} jsZip The Swagger generated archive containing the `api.ts` file
 * @return {string[]} An array of the API class names defined in `api.ts`
 */
async function createApiTs(jsZip) {
	// Read the file from the archive
	let fileContents = (await jsZip.file(API_TS).async(NODE_BUFFER)).toString();

	// Replace 'portableFetch' with regular 'fetch' if swagger gen this kind of fetch method
	fileContents = fileContents.replace(PORTABLE_PORTABLE_FETCH_REGEX, PORTABLE_FETCH_REWRITE_CONTENT);

	// Replace 'isomorphicFetch' with regular 'fetch' if swagger gen this kind of fetch method
	fileContents = fileContents.replace(PORTABLE_ISOMORPHIC_FETCH_REGEX, PORTABLE_FETCH_ISOMORPHIC_REWRITE_CONTENT);

	// Replace the BASE_PATH variable with a reference to envFacade.apiPath
	fileContents = fileContents.replace(BASE_PATH_REGEX, BASE_PATH_REWRITE_CONTENT);

	// Add the "credentials: 'include'" option to all APIs
	fileContents = fileContents.replace(INJECT_PARAMS_FIND_REGEX, INJECT_PARAMS_FIND_CONTENT);

	// Write the file to the output path
	fs.writeFileSync(path.join(SWAGGER_API_OUTPUT_PATH, API_TS), fileContents);

	// Find all class definitions deriving from the BaseAPI class and return their names as an array
	const apiClasses = fileContents.matchAll(CLASS_DEFS_REGEX);
	const proxiesToEmit = Array.from(apiClasses).map(match => match.groups['className']);
	return proxiesToEmit;
}

/**
 * Emits a class containing, for each class name in `proxiesToEmit` a static getter returning a dynamic proxy of the API object
 * @description **Note:** This method requires that the output directory already exists. The output file may or may not exist
 * 
 * The same could be done by adjusting swagger's typescript-fetch template but that is a bit overkill
 *
 * @param {string[]} proxiesToEmit An array of class names to generate getters for
 */
function emitProxiesFile(proxiesToEmit) {
	// Delete the generated file, if it already exists
	if (fs.existsSync(PROXY_EMISSION_OUTPUT_FILE)) {
		fs.unlinkSync(PROXY_EMISSION_OUTPUT_FILE);
	}

	// Ensure the output directory exists
	mkdirRecursive(PROXY_EMISSION_OUTPUT_DIR);

	// Emit static imports
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, AUTO_GEN_COMMENT);
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, PROXY_CORE_IMPORT_STATEMENT);
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, CRED_MGR_IMPORT_STATEMENT);

	// Emit dynamic imports (all classes from the Swagger generated code)
	const importStatement = createImportStatement(proxiesToEmit);
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, importStatement);

	// Emit the Facade class's beginning
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, FACADE_CLASS_START_STATEMENT);

	// Emit a getter for each proxy
	for (const proxyToEmit of proxiesToEmit) {
		fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, PROXY_GETTER_STATEMENT_FORMAT.replace(/\{0\}/g, proxyToEmit))
	}

	// Emit the facade class's end
	fs.appendFileSync(PROXY_EMISSION_OUTPUT_FILE, FACADE_CLASS_END_STATEMENT);
}

(async () => {

	// Send a Swagger Generation request
	const generateClient = {
		method: 'POST',
		body: JSON.stringify(SWAGGER_GEN_REQUEST_BODY),
		headers: { 'Content-Type': 'application/json', 'Accept': 'application/octet-stream' },
	};

	const genResponse = await nodeFetch('https://generator3.swagger.io/api/generate', generateClient);
	const buffer = await genResponse.buffer();

	// 2: Extract generated API
	const generatedZip = await jszip.loadAsync(buffer);

	// Make sure the output directory exists
	mkdirRecursive(SWAGGER_API_OUTPUT_PATH);

	// Drop some of the Swagger generated files as-is
	await depositFile(generatedZip, CONFIGURATION_TS);
	await depositFile(generatedZip, CUSTOM_D_TS);
	await depositFile(generatedZip, INDEX_TS);
	
	// Modify and drop the api.ts file
	const apiClassNames = await createApiTs(generatedZip);
	
	// Emit a Facade class with a getter for every API class in the api.ts file.
	emitProxiesFile(apiClassNames);

	// Download the latest channel TS spec API
	const channelSpecResponse = await nodeFetch(`https://raw.githubusercontent.com/coffee-paste/coffee-paste-backend/${ENV_BRANCH}/src/core/channel.protocol.ts`);
    const channelSpecBuffer = await channelSpecResponse.buffer();
	fs.writeFileSync(path.join(CHANNEL_SPEC_PATH), channelSpecBuffer);
})();
